// Generated by tools/generate-token-strings.js 2019-03-18
export module test.TokenStrings;

import Token;

export template<typename T>
T& operator<<(T& out, Token t) {
  switch (t) {
    case Token::end: return out << "end";
    case Token::error: return out << "error";
    case Token::comment: return out << "comment";
    case Token::identifier: return out << "identifier";
    case Token::whitespace: return out << "whitespace";
    case Token::template_basic: return out << "template_basic";
    case Token::template_head: return out << "template_head";
    case Token::template_middle: return out << "template_middle";
    case Token::template_tail: return out << "template_tail";
    case Token::string: return out << "string";
    case Token::regexp: return out << "regexp";
    case Token::number: return out << "number";
    case Token::left_brace: return out << "left_brace";
    case Token::right_brace: return out << "right_brace";
    case Token::left_paren: return out << "left_paren";
    case Token::right_paren: return out << "right_paren";
    case Token::left_bracket: return out << "left_bracket";
    case Token::right_bracket: return out << "right_bracket";
    case Token::semicolon: return out << "semicolon";
    case Token::colon: return out << "colon";
    case Token::comma: return out << "comma";
    case Token::question: return out << "question";
    case Token::bitwise_and: return out << "bitwise_and";
    case Token::bitwise_and_assign: return out << "bitwise_and_assign";
    case Token::bitwise_or: return out << "bitwise_or";
    case Token::bitwise_or_assign: return out << "bitwise_or_assign";
    case Token::bitwise_xor: return out << "bitwise_xor";
    case Token::bitwise_xor_assign: return out << "bitwise_xor_assign";
    case Token::bitwise_not: return out << "bitwise_not";
    case Token::bitwise_not_assign: return out << "bitwise_not_assign";
    case Token::left_shift: return out << "left_shift";
    case Token::left_shift_assign: return out << "left_shift_assign";
    case Token::left_shift_zero: return out << "left_shift_zero";
    case Token::left_shift_zero_assign: return out << "left_shift_zero_assign";
    case Token::right_shift: return out << "right_shift";
    case Token::right_shift_assign: return out << "right_shift_assign";
    case Token::right_shift_zero: return out << "right_shift_zero";
    case Token::right_shift_zero_assign: return out << "right_shift_zero_assign";
    case Token::plus: return out << "plus";
    case Token::plus_assign: return out << "plus_assign";
    case Token::minus: return out << "minus";
    case Token::minus_assign: return out << "minus_assign";
    case Token::multiply: return out << "multiply";
    case Token::multiply_assign: return out << "multiply_assign";
    case Token::divide: return out << "divide";
    case Token::divide_assign: return out << "divide_assign";
    case Token::mod: return out << "mod";
    case Token::mod_assign: return out << "mod_assign";
    case Token::pow: return out << "pow";
    case Token::pow_assign: return out << "pow_assign";
    case Token::logical_and: return out << "logical_and";
    case Token::logical_or: return out << "logical_or";
    case Token::logical_not: return out << "logical_not";
    case Token::less_than: return out << "less_than";
    case Token::less_than_equal: return out << "less_than_equal";
    case Token::greater_than: return out << "greater_than";
    case Token::greater_than_equal: return out << "greater_than_equal";
    case Token::assign: return out << "assign";
    case Token::equal: return out << "equal";
    case Token::strict_equal: return out << "strict_equal";
    case Token::not_equal: return out << "not_equal";
    case Token::strict_not_equal: return out << "strict_not_equal";
    case Token::increment: return out << "increment";
    case Token::decrement: return out << "decrement";
    case Token::dot: return out << "dot";
    case Token::dot_3: return out << "dot_3";
    case Token::fat_arrow: return out << "fat_arrow";
    case Token::kw_break: return out << "kw_break";
    case Token::kw_case: return out << "kw_case";
    case Token::kw_catch: return out << "kw_catch";
    case Token::kw_class: return out << "kw_class";
    case Token::kw_const: return out << "kw_const";
    case Token::kw_continue: return out << "kw_continue";
    case Token::kw_debugger: return out << "kw_debugger";
    case Token::kw_default: return out << "kw_default";
    case Token::kw_delete: return out << "kw_delete";
    case Token::kw_do: return out << "kw_do";
    case Token::kw_else: return out << "kw_else";
    case Token::kw_enum: return out << "kw_enum";
    case Token::kw_export: return out << "kw_export";
    case Token::kw_extends: return out << "kw_extends";
    case Token::kw_false: return out << "kw_false";
    case Token::kw_finally: return out << "kw_finally";
    case Token::kw_for: return out << "kw_for";
    case Token::kw_function: return out << "kw_function";
    case Token::kw_if: return out << "kw_if";
    case Token::kw_import: return out << "kw_import";
    case Token::kw_in: return out << "kw_in";
    case Token::kw_instanceof: return out << "kw_instanceof";
    case Token::kw_new: return out << "kw_new";
    case Token::kw_null: return out << "kw_null";
    case Token::kw_return: return out << "kw_return";
    case Token::kw_super: return out << "kw_super";
    case Token::kw_switch: return out << "kw_switch";
    case Token::kw_this: return out << "kw_this";
    case Token::kw_throw: return out << "kw_throw";
    case Token::kw_true: return out << "kw_true";
    case Token::kw_try: return out << "kw_try";
    case Token::kw_typeof: return out << "kw_typeof";
    case Token::kw_var: return out << "kw_var";
    case Token::kw_void: return out << "kw_void";
    case Token::kw_while: return out << "kw_while";
    case Token::kw_with: return out << "kw_with";
    case Token::kw_implements: return out << "kw_implements";
    case Token::kw_private: return out << "kw_private";
    case Token::kw_public: return out << "kw_public";
    case Token::kw_interface: return out << "kw_interface";
    case Token::kw_let: return out << "kw_let";
    case Token::kw_package: return out << "kw_package";
    case Token::kw_protected: return out << "kw_protected";
    case Token::kw_static: return out << "kw_static";
    case Token::kw_yield: return out << "kw_yield";
    case Token::kw_as: return out << "kw_as";
    case Token::kw_async: return out << "kw_async";
    case Token::kw_await: return out << "kw_await";
    case Token::kw_from: return out << "kw_from";
    case Token::kw_of: return out << "kw_of";
    default: return out << "?";
  }
}
