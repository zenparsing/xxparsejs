const Path = require('path');
const FS = require('fs');

const OUT_PATH = Path.resolve(__dirname, '../src/TokenTrie.cpp');
const IN_PATH = Path.resolve(__dirname, '../src/Token.cpp');

let typesFile = FS.readFileSync(IN_PATH, 'utf8');

function matchAll(text, re) {
  let out = [];
  re.lastIndex = 0;
  for (let m; m = re.exec(text);) {
    out.push(m);
  }
  return out;
}

function makeTrie(list) {
  if (list.length === 0) {
    return null;
  }

  let chars = new Map();
  let names = new Map();

  for (let [s, name] of list) {
    let c = s[0];
    if (!chars.has(c)) {
      chars.set(c, []);
    }
    if (s.length === 1) {
      names.set(c, name);
    } else {
      chars.get(c).push([s.slice(1), name]);
    }
  }

  return Array.from(chars).map(([key, value]) => {
    return {
      char: key,
      name: names.get(key) || 'error',
      children: makeTrie(value),
    };
  });
}

function trieToCode(t, depth = 0) {
  let indent = ' '.repeat(4 + depth * 2);
  let out = '';
  let varName = depth === 0 ? 'cp' : 'n';
  for (let i = 0; i < t.length; ++i) {
    let { char, name, children } = t[i];
    if (i === 0) {
      if (depth === 0) {
        out += `${ indent }if (cp == '${ char }') {\n`;
      } else if (t.length === 1) {
        out += `${ indent }if (s.peek() == '${ char }') {\n`;
      } else {
        out += `${ indent }if (auto n = s.peek(); n == '${ char }') {\n`;
      }
    } else {
      out += ` else if (${ varName } == '${ char }') {\n`;
    }
    if (depth > 0) {
      out += `${ indent }  s.advance();\n`;
    }
    if (children) {
      out += trieToCode(children, depth + 1);
    }
    out += `${ indent }  return Token::${ name };\n`
    out += `${ indent }}`;
  }
  out += `\n`;
  if (depth === 0) {
    out += `${ indent }return Token::error;\n`;
  }
  return out;
}

let tok = matchAll(typesFile, /[ \t]+kw_(\w+)/g)
  .map(m => m[1])
  .filter(k => !k.endsWith('_begin') && !k.endsWith('_end'))
  .map(k => [k, 'kw_' + k]);

function generateTokens() {
  let tok = matchAll(typesFile, /[ \t]+kw_(\w+)/g)
    .map(m => m[1])
    .filter(k => !k.endsWith('_begin') && !k.endsWith('_end'))
    .map(k => [k, 'kw_' + k]);

  return trieToCode(makeTrie(tok));
}

function generatePunc() {
  let punc = matchAll(typesFile, /(\w+),[ \t]+\/\/\s+(\S+)/g)
    .map(m => [m[2], m[1]]);

  return trieToCode(makeTrie(punc));
}

const genDate = new Date().toISOString().replace(/T.*/, '');

let code = `\
// Generated by tools/generate-tries.js ${ genDate }
export module TokenTrie;

import BasicTypes;
import Token;

export template<typename S>
struct TokenTrie {

  static Token match_punctuator(S& s, uint32 cp) {
${ generatePunc() }  }

  static Token match_keyword(S& s, uint32 cp) {
${ generateTokens() }  }

};
`;

FS.writeFileSync(OUT_PATH, code, 'utf8');
